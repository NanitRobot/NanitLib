/**
 * @if English
 * @page SPECIFICATIONS
 * @else
 * @page SPECIFICATIONS ХАРАКТЕРИСТИКИ
 * @endif
 *
 * @if English
 * @brief Technical capabilities
 *
 * Technical capabilities
 * ----------------------
 * @else
 * @brief Технічні можливості
 *
 * Технічні можливості
 * -------------------
 * @endif
 *
 * @if English
 * Nanit (hereinafter referred to as the device) is designed to study the
 * fundamentals of designing and programming automated or robotic systems
 * based on microcontrollers.
 * @else
 * Nanit (далі по тексту -- пристрій) призначений для вивчення основ
 * проектування
 * та програмування автоматизованих чи роботизованих автоматичних систем на
 * основі мікроконтролерів.
 *
 * @endif
 * <center>
 * @if English
 * #### Technical Specifications
 *
 * | Parameter                               | Value    |
 * |:--------------------------------------- |:--------:|
 * | Supply Voltage                          | 5V       |
 * | Built-in Battery Voltage                | 3.7 - 4.2V |
 * | Built-in Battery Capacity               | 1800mA-h |
 * | Battery Overcurrent and Overcharge Protection | +  |
 * | Maximum Load Current on Built-in Motor Driver | 1A |
 * | Peak Load Current on Built-in Motor Driver | 2A    |
 * | Maximum Load on Signal Pin              | 20mA     |
 * | HIGH Output Signal Voltage              | 5V       |
 * | Tolerance for 3.3V Logic                | +        |
 * | Microcontroller Clock Frequency         | 16MHz    |
 * | Program Memory Size                     | 256KB    |
 * | Non-volatile Memory Size                | 4KB      |
 * | RAM Size                                | 8KB      |
 * | Hardware Interfaces                     | 2xUART, IIC, USB |
 * | PWM Outputs                             | 12       |
 * | General-Purpose Digital I/O             | 47       |
 * | Analog Inputs Convertible to ADC Inputs | 14       |
 * | PWM-Capable Pins                        | 12       |
 * | ADC Resolution                          | 10-bit   |
 * | External Interrupts                     | 3        |
 * | Display Resolution                      | 160x128  |
 * | Number of Display Colors                | 65535    |
 * | Number of Physical Ports                | 12       |
 * @else
 *
 * #### Технічні дані
 *
 * |Параметр                            | Значення |
 * |:-----------------------------------|:--------:|
 * |Напруга живлення                    |    5В    |
 * |Напруга живлення вбудованої батареї |3,7 — 4,2В|
 * |Ємність вбудованого акумулятора     | 1800mA-h |
 * |Захист батареї від КЗ та перерозряду|    +     |
 * |Максимальний струм навантаження на<BR/> вбудований драйвер двигуна|1A|
 * |Піковий струм навантаження на вбудований драйвер двигуна|2A|
 * |Максимальне навантаження на сигнальний пін|20мА|
 * |Вихідний сигнал HIGH                |   5В     |
 * |Толерантність то 3.3вольт логіки    |    +     |
 * |Тактова частота мікроконтролера     |  16МГц   |
 * |Об’єм пам’яті програми              |  256KB   |
 * |Об’єм енергонезалежної пам’яті      |   4KB    |
 * |Об’єм оперативної пам’яті           |   8KB    |
 * |Апаратні інтерфейси                 |2xUART, IIC, USB|
 * |ШІМ виводів                         |   12     |
 * |Цифрові входи/виходи загального призначення|47 |
 * |Можуть працювати в режимі АЦП входи |   14     |
 * |Можуть працювати в режимі ШІМ       |   12     |
 * |Розрядність АЦП                     | 10bit    |
 * |Зовнішнє переривання                |   3      |
 * |Роздільна здатність дисплею         |160х128   |
 * |Кількість кольорів дисплею          | 65535    |
 * |Кількість фізичних  портів          |   12     |
 * @endif
 *
 * <br />
 *
 * #### PinOut
 *
 * ![Arduino](https://raw.githubusercontent.com/NanitRobot/NanitLib/main/pic/PinOutArduino.jpg)
 * |Nanitdef               |Analog |    PIN       |        |        |
 * |:---------------------:|:-----:|:------------:|:------:|:------:|
 * |      @ref P1_1        |  A7   |   61(IO)     |  *PF7* |   IO   |
 * |      @ref P1_2        |  A6   |   60(IO)     |  *PF6* |   IO   |
 * |      @ref P1_3        |    @ref DiffPin              ||| O    |
 * |      @ref P1_4        |    @ref DiffPin              ||| O    |
 * |      @ref P2_1        |  A10  |   64(IO)     |  *PK2* |   IO   |
 * |      @ref P2_2        |  A9   |   63(IO)     |  *PK1* |   IO   |
 * |      @ref P2_3        |       |   42(IO)     |  *PL7* |   IO   |
 * |      @ref P2_4        |  A8   |   62(IO)     |  *PK0* |   IO   |
 * |      @ref P3_1        |     @ref MEGACORE             |||  IO  |
 * |      @ref P3_2        |       |    25(IO)    |  *PA3* |   IO   |
 * |      @ref P3_3        |       |    30(IO)    |  *PC7* |   IO   |
 * |      @ref P3_4        |       |    31(IO)    |  *PC6* |   IO   |
 * |      @ref P4_1        |  A11  |    65(IO)    |  *PK3* |   IO   |
 * |      @ref P4_2        |       |    44(IO)    |  *PL5* |   IO   |
 * |      @ref P4_3        |       |    45(IO)    |  *PL4* |   IO   |
 * |      @ref P4_4        |       |    46(IO)    |  *PL3* |   IO   |
 * |      @ref P5_1        |       |    2(IO)     |  *PE4* |   IO   |
 * |      @ref P5_2        |  A1   |    54(IO)    |  *PF0* |   IO   |
 * |      @ref P5_3        |  A12  |    66(IO)    |  *PK4* |   IO   |
 * |      @ref P5_4        |       |    33(IO)    |  *PC4* |   IO   |
 * |      @ref P6_1        |       |    23(IO)    |  *PA1* |   IO   |
 * |      @ref P6_2        |  A14  |    67(IO)    |  *PK6* |   IO   |
 * |      @ref P6_3        |  A13  |    67(IO)    |  *PK5* |   IO   |
 * |      @ref P6_4        |       |    22(IO)    |  *PA0* |   IO   |
 * |      @ref P7_1        |   A3  |    57(IO)    |  *PF3* |   IO   |
 * |      @ref P7_2        |   A4  |    58(IO)    |  *PF4* |   IO   |
 * |      @ref P7_3        |       |    25(IO)    |  *PA3* |   IO   |
 * |      @ref P7_4        |    @ref DiffPin              |||  IO   |
 * |      @ref P8_1        |       |      1       |  *PE1* |   IO   |
 * |      @ref P8_2        |       |      0       |  *PE0* |   IO   |
 * |      @ref P8_3        |       |      5       |  *PE3* |   IO   |
 * |      @ref P8_4        |                 RESET                 ||||
 * |      @ref P9_1        |       |    21(IO)    |  *PD0* |   IO   |
 * |      @ref P9_2        |       |    20(IO)    |  *PD1* |   IO   |
 * |      @ref P9_3        |       |    19(IO)    |  *PD2* |   IO   |
 * |      @ref P9_4        |    @ref DiffPin              |||  IO   |
 * |     @ref P10_1        |   A2  |    56(IO)    |  *PF2* |   IO   |
 * |     @ref P10_2        |    @ref DiffPin              |||  IO   |
 * |     @ref P10_3        |    @ref DiffPin              |||  IO   |
 * |     @ref P10_4        |       |    6(IO)     |  *PH3* |   IO   |
 * |     @ref P11_1        |       |                      ||   O    |
 * |     @ref P11_2        |       |                      ||   O    |
 * |     @ref P11_3        |       |    43(IO)    |  *PL6* |   IO   |
 * |     @ref P11_4        |       |    32(IO)    |  *PC5* |   IO   |
 * |     @ref P12_1        |       |    36(IO)    |  *PC1* |   IO   |
 * |     @ref P12_2        |       |    34(IO)    |  *PC3* |   IO   |
 * |     @ref P12_3        |       |     12(O)    |  *PB6* |   O    |
 * |     @ref P12_4        |       |     11(O)    |  *PB5* |   O    |
 * |   @ref BATTERY_PIN    |  A15  |      --      |   I    |        |
 * |  @ref MOTOR_ENABLE    |       |     40(O)    |   O    |        |
 * |   @ref MOTOR_FAIL     |       |     41(I)    |   I    |        |
 * | @ref BUILDIN_STRIP_LED|       |     27(O)    |   O    |        |
 * | @ref LED_BUILTIN      |       |      4(O)    |        |        |
 *
 * </center>
 * @if English
 *
 * \b I -- pin can work only on input
 *
 * \b O -- The pin can only work on output pin
 *
 * \b IO -- The pin can be used for both input and output
 *
 *
 * @else
 *
 *  \b I -- пін може працювати тільки на вхід
 *
 *  \b O -- Пін може працювати тільки на вивід
 *
 *  \b IO -- Пін може бути використаний як на вхід так і на вихід
 *
 * @endif
 *
 *
 * @if English
 * @defgroup factory_settings Default firmware
 * @else
 * @defgroup factory_settings Прошивки за замовчуванням
 * @endif
 * @{
 *
 *
 * @if English
 *
 * @else
 * Тут знаходяться прошивки для ```Nanit``` які йдуть за замовчуванню.
 * Якщо, в процесі вивчення програмування, ви не змогли самостійно написати
 * алгоритми поведінки, які реалізовано нами, і вам хочеться погратися з режимами
 * які для вас написали творці та автори, `Nanit` ви можете відновити їх за
 * допомомогою функцій IDE Arduino, або скориставшись спеціальною утилітою
 * @endif
 *
 * @if English
 * To start the recovery through the Arduino IDE, make sure that the editors
 * the latest version of the Nanit board package is installed. The update is recommended as follows
 * how you will get the latest versions of the programs. (We are constantly working on this).
 *
 * If the package of our boards is not installed, use the how-to instructions
 * set @ref BoardManager. After installing the board manager, you can
 * continue to follow the instructions described in this section.
 *
 * @else
 * Для початку відновлення через Arduino IDE переконайтеся, що в редакторі
 * встановлено найновішу версію пакунка плат Nanit. Оновлення рекомендоване оскільки
 * ви отримаєте найновіші версії програм. (Ми постійно працюємо над цим).
 *
 * Якщо пакунок наших плат не втановлено скористайтеся інструкцією як
 * встановлювати  @ref BoardManager. Після встановлення менеджера плат ви можете
 * продовжити виконання інструкцій описаних у цьому розділі.
 *
 * @endif
 *
 * <div class="tabbed">
 * <ul>
 *  <li> <b class="tab-title">IDE 1.8.x</b>
 *   @if English
 *   1) Connect the device to the PC using a cable that is compatible with the
 *   device
 *   @else
 *   1) Підключіть пристрій до ПК за допомогою кабелю, який сумісний з пристроєм
 *   @endif
 * 
 *   @if English
 *   2) In the menu `Tools` &rarr; `Board` &rarr; `NanitRobot` &rarr; select
 *   device type or board
 *   on which the firmware will be restored or updated, for example, `Nanit
 *   Discovery`
 *   @else
 *   2) В меню `Tools` &rarr; `Board` &rarr; `NanitRobot` &rarr; оберіть тип
 *   пристрою або плату
 *   на якій буде відновлюватись чи оновлюватися прошивка, наприклад, `Nanit
 *   Discovery`
 *   @endif
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_1.8.x/1.SelectBoard.png)
 *  
 *   @if English
 *   3) Depending on the selected device, additional options for
 *   recovery. For example, you will need to choose a case type for the Discovery
 *   set device `Tools` &rarr; `Casing` &rarr; `ABS`
 *  
 *   @else
 *   3) В залежності від обраного пристрою в меню з'являться додаткові опції для
 *   відновлення. Наприклад для Дискавері набору потрібно буде обрати тип корпусу
 *   пристрою
 *   `Tools` &rarr; `Casing` &rarr; `ABS`
 *   @endif
 * 
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_1.8.x/2.SelectCasing.png)
 *  
 *  
 *   @if English
 *   4) Select the port to which the device is connected from the menu
 *   `Tools` &rarr; `Port` &rarr; device
 *   Usually, the port is additionally signed `Nanit Discovery`
 *
 *   @else
 *   4) Виберіть з меню порт до якого підключено пристрій
 *   `Tools` &rarr; `Port` &rarr; пристрій
 *   зазвичай порт додатково підписаний `Nanit Discovery`
 *   @endif
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_1.8.x/3.SelectPort.png)
 *   
 *   @if English
 *   5) Select the programmer through which the firmware will be restored
 *   `Tools` &rarr; `Programmer` &rarr; `NanitBuildin`
 *   @else
 *   5) Оберіть програматор через який буде відновлюватись прошивка
 *   `Tools` &rarr; `Programer` &rarr; `NanitBuildin`
 *   @endif
 *  
 *   @if English
 *   In this case, the built-in programmer will be used to restore the firmware
 *   For the use of other programmers, physical access to the `ISP` connector is
 *   required and the corresponding programmer.
 *   @else
 *   В цьому випадку для відновлення прошивки буде використовуватись вбудований
 *   програматор Для використання інших програматорів потрібен фізичний доступ до
 *   роз'єму `ISP`
 *   та відповідний програматор.
 *   @endif
 *  
 *   @if English
 *   <i>If your programmer is not on the list - contact us and we will add it</i>
 *   @else
 *   <i>Якщо вашого програматора немає у списку - зверніться до нас і ми його
 *   додамо</i>
 *   @endif
 *  
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_1.8.x/4.SelectBrogramer.png)
 *  
 *  
 *   @if English
 *   6) Choose
 *   `Tools` &rarr; `Burn bootloader`
 *   After that, the program update process will begin. Depending on the setting,
 *   which have been completed by the steps above will be updated or only the main
 *   software code, or the software code together with the bootloader firmware
 *   @else
 *   6) Оберіть
 *   `Tools` &rarr;  `Burn bootloader`
 *   Після цього почнеться процес оновлення програми. У залежності від
 *   налаштуваня, які були виконані кроками вище, буде оновлено або лише основний програмний
 *   код, або програмний код разом з мікропрограмою бутлоадера
 *   @endif
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_1.8.x/5.Burn.png)
 *  
 * 
 * 
 *  </li>
 *  <li> <b class="tab-title">IDE 2.x</b>
 *   @if English
 *   1) Connect the device to the PC using a cable that is compatible with the
 *   device
 *   @else
 *   1) Підключіть пристрій до ПК за допомогою кабелю, який сумісний з пристроєм
 *   @endif
 * 
 *   @if English
 *   2) In the menu `Tools` &rarr; `Board` &rarr; `NanitRobot` &rarr; select
 *   device type or board
 *   on which the firmware will be restored or updated, for example, `Nanit
 *   Discovery`
 *   @else
 *   2) В меню `Tools` &rarr; `Board` &rarr; `NanitRobot` &rarr; оберіть тип
 *   пристрою або плату
 *   на якій буде відновлюватись чи оновлюватися прошивка, наприклад, `Nanit
 *   Discovery`
 *   @endif
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_2.x/1.SelectBoard.png)
 *    
 *  
 *   @if English
 *   3) Depending on the selected device, additional options for
 *   recovery. For example, you will need to choose a case type for the Discovery
 *   set device `Tools` &rarr; `Casing` &rarr; `ABS`
 *  
 *   @else
 *   3) В залежності від обраного пристрою в меню з'являться додаткові опції для
 *   відновлення. Наприклад для Дискавері набору потрібно буде обрати тип корпусу
 *   пристрою
 *   `Tools` &rarr; `Casing` &rarr; `ABS`
 *   @endif
 *  
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_2.x/2.SelectCasing.png)
 *   
 * 
 *   @if English
 *   4) Select the port to which the device is connected from the menu
 *   `Tools` &rarr; `Port` &rarr; device
 *   Usually, the port is additionally signed `Nanit Discovery`
 *
 *   @else
 *   4) Виберіть з меню порт до якого підключено пристрій
 *   `Tools` &rarr; `Port` &rarr; пристрій
 *   зазвичай порт додатково підписаний `Nanit Discovery`
 *   @endif
 * 
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_2.x/3.SelectPort.png)
 *  
 *  
 *   @if English
 *   5) Select the programmer through which the firmware will be restored
 *   `Tools` &rarr; `Programmer` &rarr; `NanitBuildin`
 *   @else
 *   5) Оберіть програматор через який буде відновлюватись прошивка
 *   `Tools` &rarr; `Programer` &rarr; `NanitBuildin`
 *   @endif
 * 
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_2.x/4.SelectBrogramer.png)
 *  
 *  
 *   @if English
 *   In this case, the built-in programmer will be used to restore the firmware
 *   For the use of other programmers, physical access to the `ISP` connector is
 *   required and the corresponding programmer.
 *   @else
 *   В цьому випадку для відновлення прошивки буде використовуватись вбудований
 *   програматор Для використання інших програматорів потрібен фізичний доступ до
 *   роз'єму `ISP`
 *   та відповідний програматор.
 *   @endif
 *  
 *   @if English
 *   <i>If your programmer is not on the list - contact us and we will add it</i>
 *   @else
 *   <i>Якщо вашого програматора немає у списку - зверніться до нас і ми його
 *   додамо</i>
 *   @endif
 *  
 *  
 *   @if English
 *   6) Choose
 *   `Tools` &rarr; `Burn bootloader`
 *   After that, the program update process will begin. Depending on the setting,
 *   which have been completed by the steps above will be updated or only the main
 *   software code, or the software code together with the bootloader firmware
 *   @else
 *   6) Оберіть
 *   `Tools` &rarr;  `Burn bootloader`
 *   Після цього почнеться процес оновлення програми. У залежності від
 *   налаштувань, які були виконані кроками вище, буде оновлено або лише основний програмний
 *   код, або програмний код разом з мікропрограмою бутлоадера
 *   @endif
 * 
 * 
 *   ![](https://nanitrobot.github.io/static/pic/Arduino_2.x/5.Burn.png)
 *  
 * 
 *  </li>
 *  <li> <b class="tab-title">CLI</b>
 *    @if English
 *    __ATTENTION this command is only valid for ```LinuxOS```__
 *    @else
 *    __УВАГА ця комада валідна тільки для ```LinuxOS```__
 *    @endif
 * 
 *   ```zsh
 *   avrdude -c wiring -p m2560  -U flash:w:./NanitInfo.ino.hex:i -P /dev/ttyUSB0
 *   ```
 *   @if English
 *   \b Explanation
 *   @else
 *   \b Пояснення
 *   @endif
 * 
 *   @if English
 *   We run `avrdude` using the built-in programmer (`wiring`) for the __ATmega2560__ 
 *   microcontroller to write the contents of the file 
 *   [NanitInfo.ino.hex](https://nanitrobot.github.io/NanitLib/binary/NanitInfo.ino.hex),
 *   which contains the executable code in IntelHex format, to the flash memory: `i` 
 *   through port `/dev/ttyUSB0`
 *   @else
 *   Запускаємо `avrdude` з використанням вбудованого програматора (`wiring`) 
 *   для мікроконтроллера __ATmega2560__ запису у флеш пам'ять вмісту файлу 
 *   [NanitInfo.ino.hex](https://nanitrobot.github.io/NanitLib/binary/NanitInfo.ino.hex), 
 *   який містить виконуваний код у  форматі  IntelHex `:i` через порт
 *   @endif 
 * 
 *   * [NanitInfo.ino.with_bootloader.hex](https://nanitrobot.github.io/NanitLib/binary/NanitInfo.ino.with_bootloader.hex)
 *   * [NanitInfo.ino.hex](https://nanitrobot.github.io/NanitLib/binary/NanitInfo.ino.hex)
 *   * [AllNanit.zip](https://nanitrobot.github.io/NanitLib/AllNanit.zip)
 * 
 *   <center>
 *   |   Fuse  | Value|
 *   |:-------:|:----:|
 *   | lock    | 0x3F |
 *   | hfuse   | 0xD8 |
 *   | lfuse   | 0xFF |
 *   | efuse   | 0xFD |
 *   </center>
 * 
 *   \b Supported \b programmers
 * 
 *   @if English
 *   To find out the supported programmers by your bootloader recording utility, you need to enter the command
 *   @else
 *
 *   @endif  
 *   
 *   ```zsh
 *     avrdude -c what
 *   ```
 *
 * </li>
 * </ul>
 * </div>
 * 
 * @if English
 *
 * @else
 *
 * @endif
 *
 * @}
 */
/*
 *   [nanite_v3.1.ino.with_bootloader.hex](https://nanitrobot.github.io/NanitLib/binary/nanite_v3.1.ino.with_bootloader.hex)
 *
 *   [nanite_v3.1.ino.hex](https://nanitrobot.github.io/NanitLib/binary/nanite_v3.1.ino.hex)
 * 
 */